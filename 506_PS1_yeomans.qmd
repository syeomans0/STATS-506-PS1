---
title: "STATS 506 - Problem Set #1"
author: "Sydney Yeomans"
format: html
editor: visual
---

Github URL: <https://github.com/syeomans0/STATS-506-PS1>

## Problem 1

Download the data set about abalones (a type of sea snail) and do the following:

a.  Import the data into a data.frame and give the appropriate column names.

```{r}
#| echo: true
abalones_df <- read.csv("abalone.data", header = FALSE)
```

```{r}
#| echo: true
#Rename the columns based on what is in the abalone name file
#Names of variables are the following:
#V1 = Sex, V2 = Length, V3 = Diameter, V4 = Height 
#V5 = Whole weight, V6 = Shucked weight, V7 = Viscera weight
#V8 = Shell weight, V9 = Rings

colnames(abalones_df) <- c("Sex", 
                           "Length", 
                           "Diameter", 
                           "Height", 
                           "Whole_weight", 
                           "Shucked_weight", 
                           "Viscera_weight", 
                           "Shell_weight", 
                           "Rings")

head(abalones_df)

```

b.  The data contains information on three different sexes of abalone. Report the number of observations belonging to each sex.

```{r}
#| echo: true
table(abalones_df$Sex)
```

In this data set there are 1307 females, 1528 males, and 1342 infants.

c.  

    i.  Which weight has the highest correlation with rings?

```{r}
#| echo: true
#There are four different weights so need four correlations 
whole_cor <- cor(abalones_df$Whole_weight, abalones_df$Rings)
print(whole_cor)

shucked_cor <- cor(abalones_df$Shucked_weight, abalones_df$Rings)
print(shucked_cor)

viscera_cor <- cor(abalones_df$Viscera_weight, abalones_df$Rings)
print(viscera_cor)

shell_cor <- cor(abalones_df$Shell_weight, abalones_df$Rings)
print(shell_cor)
```

The weight with the highest correlation to rings is shell weight with a value of $.627$.

ii. For that weight, which sex has the highest correlation?

```{r}
#| echo: true
#Split the data set into three separate ones based on sex
males <- abalones_df[abalones_df$Sex == "M", ]
females <- abalones_df[abalones_df$Sex == "F", ]
infants <- abalones_df[abalones_df$Sex == "I", ]

#Now we can do the correlations for each for shell weight and rings
male_cor_shell <- cor(males$Shell_weight, males$Rings)
print(male_cor_shell)
female_cor_shell <- cor(females$Shell_weight, females$Rings)
print(female_cor_shell)
infant_cor_shell <- cor(infants$Shell_weight, infants$Rings)
print(infant_cor_shell)

```

The sex with the highest correlation between shell weight and rings is infants. I looked up how to make a new data frame from an existing one and used the source below to help me make the three new ones based on each of the different sexes.

Source: <https://stackoverflow.com/questions/43347110/how-to-create-new-dataframe-from-existing-dataframe-selecting-rows-matching-two>

iii. What are the weights of the abalone with the most rings?

```{r}
#| echo: true

most_rings <- abalones_df[abalones_df$Rings == max(abalones_df$Rings),]
print(most_rings)

```

The most number of rings for an abalone in this data set is $29$. The weights of the abalone with this many rings is in the table above, but just in case I will list them out as well: whole_weight $=1.8075$, shucked_weight $=.7055$, viscera_weight $=.3215$, and shell_weight $=.475$.

Note: originally had the `max` function on its own, but the output looked bad so I moved it to the inside of the new data frame I created.

iv. What percentage of abalones have a viscera weight larger than their shell weight?

```{r}
#| echo: true
viscera_greater_shell <- sum(abalones_df$Viscera_weight > abalones_df$Shell_weight)
viscera_greater_shell

#Total number of abalones are the number of observations in the data frame - 4177
percentage <- 272/4177
percentage * 100
```
The percentage of abalones that have a viscera weight larger than their shell weight is $6.51\%$.

d. Create a table of correlations between weights and rings, within each sex. The columns should be the four weights, and the rows should be the sexes. 

```{r}
#| echo: true
#Have to find the correlations for each of the other weights
#whole, shucked, and viscera within each sex
males_cor_whole <- cor(males$Whole_weight, males$Rings)
females_cor_whole <- cor(females$Whole_weight, females$Rings)
infants_cor_whole <- cor(infants$Whole_weight, infants$Rings)
  
males_cor_shucked <- cor(males$Shucked_weight, males$Rings)
females_cor_shucked <- cor(females$Shucked_weight, females$Rings)
infants_cor_shucked <- cor(infants$Shucked_weight, infants$Rings)

males_cor_viscera <- cor(males$Viscera_weight, males$Rings)
females_cor_viscera <- cor(females$Viscera_weight, females$Rings)
infants_cor_viscera <- cor(infants$Viscera_weight, infants$Rings)
  
  
#Create a table with these values: columns = weights, rows = sex
cor_table <- data.frame(whole_weight = 
                          c(males_cor_whole, females_cor_whole, infants_cor_whole), 
                        shucked_weight = 
                          c(males_cor_shucked, females_cor_shucked, infants_cor_shucked), 
                        viscera_weight = 
                          c(males_cor_viscera, females_cor_viscera, infants_cor_viscera), 
                        shell_weight = 
                          c(male_cor_shell,female_cor_shell, infant_cor_shell))

row.names(cor_table) <- c("Males", "Females", "Infants")

cor_table
  
```
This is a table that looks at the correlation between the four different weights of the data set and rings broken down by the three different sexes. 

e. Carry out a series of t-tests to examine whether the number of rings differs across the three sexes. Present the R output and interpret the results. 

```{r}
#| echo: true
#Have to compare M to F, M to I, and F to I
t.test(abalones_df$Rings[abalones_df$Sex == "M"], 
       abalones_df$Rings[abalones_df$Sex == "F"])

t.test(abalones_df$Rings[abalones_df$Sex == "M"], 
       abalones_df$Rings[abalones_df$Sex == "I"])

t.test(abalones_df$Rings[abalones_df$Sex == "F"], 
       abalones_df$Rings[abalones_df$Sex == "I"])
```
From the three t-tests it can be seen that there is evidence that the number of rings differ across all three sexes, as seen from the very small p-values when comparing the sexes to each other. 

## Problem 2

a. Import the food expenditures data frame.

```{r}
#| echo: true
food_exp_df <- read.csv("food_expenditure.csv")
```

b. Clean up the variable names by simplifying them.

```{r}
#| echo: true
colnames(food_exp_df) <- c("ID", 
                           "Age", 
                           "Household_size", 
                           "State", 
                           "Currency", 
                           "Total_food_expenditure", 
                           "Grocery_cost", 
                           "Dining_out_cost", 
                           "Miscellaneous_cost", 
                           "Times_dine_out", 
                           "Alcohol", 
                           "Food_assist")
head(food_exp_df)
```

c. Restrict the data to those paying in US dollars (USD). Show that it worked by confirming the number of observations before and after restricting the data.

```{r}
#| echo: true
nrow(food_exp_df)

#Restrict to only USD
food_exp_df <- food_exp_df[food_exp_df$Currency == "USD",]
nrow(food_exp_df)
```
For each of the following variables, clean them by removing any row with inappropriate data. For each variable, explain your rules for eliminating rows.

d. The variable related to age. Rules used to clean up the age variable: First, got rid of all minors below 18. And then, I got rid of anyone who was older than 100.

```{r}
#| echo: true
#First drop all NAs
food_exp_df <- na.omit(food_exp_df)
nrow(food_exp_df)

#Get rid of minors:
food_exp_df <- food_exp_df[food_exp_df$Age >= 18,]
nrow(food_exp_df)

#Get rid of any ages over 100: 
food_exp_df <- food_exp_df[food_exp_df$Age <= 100, ]
nrow(food_exp_df)
```

e. The variable related to state. Rules used to clean up the state variable: Get rid of the value in state called XX. There were also a few from PR (Puerto Rico) and I got rid of it, focusing on US states rather than territories.

```{r}
#| echo: true
#Get rid of XX state abbreviation:
food_exp_df <- food_exp_df[food_exp_df$State != "XX",]
nrow(food_exp_df)

#Get rid of PR: 
food_exp_df <- food_exp_df[food_exp_df$State != "PR",]
nrow(food_exp_df)
```

f. The four variables related to food expenditures. Rules to clean up the four food expenditures: For the all the food expenditure variables I got rid of any value less than or equal to 0.

```{r}
#| echo: true
#Get rid of 0s and negative values for all four variables related to food expenditures:
#Total
food_exp_df <- food_exp_df[food_exp_df$Total_food_expenditure > 0,]

#Grocery cost
food_exp_df <- food_exp_df[food_exp_df$Grocery_cost > 0,]

#Dining out cost
food_exp_df <- food_exp_df[food_exp_df$Dining_out_cost > 0,]

#Miscellaneous
food_exp_df <- food_exp_df[food_exp_df$Miscellaneous_cost > 0,]

nrow(food_exp_df)

```

g. The variable related to number of times dining out. Rules used to clean up the times dining out variable: there were a few rows where the times dining out were 0 but the person still said there was dining out cost so I dropped the rows where this was the case.

```{r}
#| echo: true
#Want to get rid of the people who said they didn't eat out but had dining out cost > 0:
food_exp_df <- food_exp_df[!(food_exp_df$Times_dine_out == 0 & food_exp_df$Dining_out_cost > 0), ]

nrow(food_exp_df)
```

h. Report your final number of observations after this cleaning.

```{r}
#| echo: true
dim(food_exp_df)
```
The final number of observations after cleaning everything was 118. 

## Problem 3

a. Write function `nextCollatz` that given a positive integer, computes the next number in its Collatz sequence. Be sure to provide a reasonable error on an invalid input. Be sure to document your function. 

```{r}
#| echo: true
#' Function that computes the next value in the Collatz sequence
#'
#' @param : a positive integer
#' @return : the next value in the sequence (one value), positive integer
nextCollatz <- function(n){
  if (n <= 0) {
    stop("n must be a positive integer")
  }
  if (!is.numeric(n)) {
    stop("n must be numeric")
  }
  
  if((n %% 2) == 0) {
    n <- n / 2
    return(n)
} else {
    n <- (3 * n) + 1
    return(n)
}
  
}

nextCollatz(5)
nextCollatz(16)
```

b. Create a function `collatzSequence` that returns the Collatz sequence for a given input. Use your `nextCollatz` function to perform the calculation. Be sure to provide a reasonable error on an invalid input. Be sure to document your function.

```{r}
#| echo: true
#' Function that gives the Collatz sequence after getting a number, stopping at 1
#'
#' @param : a positive integer 
#' @return : a list containing the vector of the entries in the Collatz sequence beginning at the input and ending at 1; and the length of the Collatz sequence
collatzSequence <- function(n){
  if (n <= 0) {
    stop("n must be a positive integer")
  }
  if (!is.numeric(n)) {
    stop("n must be numeric")
  }
  
  collatz_seq <- n
  while (n != 1) {
    if((n %% 2) == 0) {
    n <- n / 2
} else {
    n <- (3 * n) + 1
}
    collatz_seq <- c(collatz_seq, n)
  }
  return(list(collatz_seq, length(collatz_seq)))
}

collatzSequence(5)
collatzSequence(19)
```

c. Use these functions to find the shortest and longest Collatz sequence starting with values between 100 and 500, inclusive. In the case of ties, report the lowest starting value.

```{r}
#| echo: true
#Set the shortest and longest sequence to be kind of nonsense 
#so that we can update them right away starting with the first value 100
shortest_seq_length <- 1000
longest_seq_length <- 1

# In the case of ties, report the lowest starting value, currently don't have ties so NAs to start
tie_breaker_shortest <- NA
tie_breaker_longest <- NA

#Go through 100 - 500 inclusive and check against our starting values above
for (i in 100:500) {
  get_seq <- collatzSequence(i)
  seq_length <- get_seq[[2]] #the length value from the list in the sequence function I wrote earlier
  
#if the sequence length from sequence function is shorter than 1000 want to update it to be the length from seqeuence function and set the start value to be i
  if (seq_length < shortest_seq_length) {
    shortest_seq_length <- seq_length
    tie_breaker_shortest <- i
  } 
#in case the lengths are exactly equal we have to find the smaller starting value
  if (seq_length == shortest_seq_length) {
    if (i < tie_breaker_shortest) {
      tie_breaker_shortest <- i
    }
  }
  #use same code but do it for the longest one
  if (seq_length > longest_seq_length) {
    longest_seq_length <- seq_length
    tie_breaker_longest <- i
  } 
  
  if (seq_length == longest_seq_length) {
    if (i < tie_breaker_longest) {
      tie_breaker_longest <- i
    }
  }
}

cat("The shortest sequence has length of", shortest_seq_length, "and it starts with value", tie_breaker_shortest,".")

cat(" The longest sequence has length of", longest_seq_length, "and it starts with value", tie_breaker_longest, ".")
```
I used the second source to help me write a print statement that combined string and my variables but I ran into some issues when using that so ChatGPT told me to use `cat()` instead so I wouldn't get an error. I used this website to check if my outputs made sense <https://www.dcode.fr/collatz-conjecture>, which they did. I had `else if` at first to check the length equality after looking at the first source listed. After looking back at this, I found the `else if` confusing so I just changed it to all if statements.

Sources for this problem: <https://www.w3schools.com/r/r_if_else.asp>, <https://stackoverflow.com/questions/15589601/print-string-and-variable-contents-on-the-same-line-in-r>

